std::unordered_map<int, std::vector<std::pair<int, int>>> rules = {
{31,{{16,9},{22,3},{3,6}}},
{38,{{22,3},{3,1},{1,8},{8,17}}},
{41,{{40,9},{7,2}}},
{44,{{40,9},{11,5}}},
{45,{{40,9},{11,5},{26,10},{15,1}}},
{50,{{41,8},{14,2},{1,24},{9,16},{7,18}}},
{71,{{11,25},{20,5},{50,14},{15,1},{68,32},{32,4},{21,15},{1,3}}},
{94,{{24,12},{74,7},{7,2},{2,14},{11,5},{15,10}}},
{95,{{49,51},{26,38},{28,8},{8,1},{1,3},{3,6},{6,10}}},
{96,{{49,51},{26,38},{28,8},{8,1},{1,3},{3,6},{6,10}}},
{100,{{48,16},{16,9},{9,27} ,{35,1},{1,15} ,{10,6}}},
{105,{{7,2},{23,13},{38,11}}},
{108,{{44,37},{8,1},{11,5},{17,19}}},
{109,{{87,82},{52,29},{20,5},{5,11}}},
{110,{{56,8},{8,1},{52,12},{3,22},{11,5}}},
{111,{{4,21},{21,15},{22,3},{3,6}}},
{112,{{47,2},{23,13},{13,3},{3,22},{29,7},{9,16},{16,20}}},
{113,{{26,10},{28,8}}},
{114,{{24,1},{5,20},{16,9}}},
{115,{{36,13},{13,12},{39,25},{8,1},{1,3},{58,6}}},
{116,{{47,2},{21,28},{8,1},{1,24},{24,25},{9,16}}},
{117,{{60,21},{33,16},{7,2}}},
{118,{{48,1},{28,8},{10,6}}},
{119,{{22,3},{36,28},{28,8},{1,15},{4,5},{10,6}}},
{121,{{7,2},{2,23},{26,10},{15,21},{21,4},{4,5},{11,25},{45,19},{30,6}}},
{129,{{59,22},{22,3},{43,3},{43,6},{6,30},{62,2},{2,14},{58,42},{1,24},{12,4}}},
{137,{{29,20},{20,5},{34,2},{21,4},{4,12},{13,36}}},
{138,{{2,12}}},
{139,{{15,21},{21,4},{30,6},{17,8},{8,1},{20,5},{11,25}}},
{140,{{116,80},{51,30},{30,19},{19,6},{34,2},{4,21}}},
{141,{{38,26},{55,9},{78,22},{14,11},{10,6},{6,30},{30,19},{4,5},{1,8}}},
{142,{{73,8},{8,17},{17,32},{35,1},{30,19},{10,15},{15,21},{21,4},{4,5},{22,14},{11,38}}},
{145,{{111,114},{39,25},{40,9},{20,5}}},
{336,{{17,19},{10,26}}},
{384,{{48,33}}},
{451,{{45,4},{4,21}}},
{415,{{79,21},{15,1},{1,8},{48,16},{61,20},{20,5},{5,4},{10,26}}},
{539,{{34,2},{23,58},{4,21},{21,15},{5,11},{31,18},{3,1}}},
{540,{{73,27},{54,10},{6,19},{4,12},{12,24},{25,11},{484,477},{11,5},{33,3}}},
{575,{{23,2},{35,29},{7,18}}},
{729,{{20,16},{4,5},{54,10},{6,19}}},
{750,{{47,2},{31,18},{7,9}}},
{751,{{30,6},{6,10},{23,2}}},
{752,{{29,20},{44,37},{27,22},{22,3}}},
{753,{{541,483}}},
{754,{{690,606},{541,483}}},
{755,{{690,606},{614,682},{689,680},{541,483},{5,11},{7,2},{34,15}}},
{756,{{58,42},{42,22}}},
{757,{{9,55},{23,2},{53,11},{11,5},{5,4},{4,12}}},
{759,{{685,759},{57,7},{49,32},{17,19},{19,6}}},
{833,{{27,54},{39,25},{53,28},{21,4},{20,16}}},
{834,{{766,678},{687,682},{535,489},{64,36},{13,12}}},
{835,{{766,678},{72,9},{52,12},{76,5}}},
{885,{{69,12}}},
{936,{{34,15},{15,1},{39,10},{28,21},{24,25},{17,32}}},
{963,{{38,11},{11,5},{5,4},{17,19}}},
};

//   for (int i = 1; i <= base; i++) {
//     squaredVec.push_back(i * i);
//   }
  
//   // Find complementary numbers
//   std::unordered_map<int, Number> cmpMap;
//   for(int idx = 1; idx <= n; ++idx) {
//     cmpMap[idx].value = idx;
//   }
  
//   // Number which start the series, by default it is 1 and during search it
//   // should be set to number which has only one complementary value if such exist,
//   // otherwise default stay unchange.
//   int currentNum = 1;
//   // Initial value of the number of numbers which can have only one complementary
//   int numberWithOneComp = 2;
  
//   for (int idx = 1; idx <= n; ++idx) {
//     // Amount of complementary number finded for the num
//     int cmpCount = 0;
//     Number& num = cmpMap[idx];
    
//     for(auto squared : squaredVec) {
//       int cmpNum = squared - num.value;
//       if(cmpNum > 0 && cmpNum <= n && cmpNum != num.value) {
//         cmpCount++;
//         num.cmpVec.push_back(cmpNum);
//       }
//     }

//    // std::cout << "Size: " << currentNum  << " : "<< cmpMap[currentNum].cmpVec.size() << std::endl;
//     //if(num.value != 1 &&  cmpMap[currentNum].cmpVec.size() < cmpCount) {
//     //  currentNum = num.value;
//     //}
//     // Check if only one complementary 
//     currentNum = num.value;
//     std::cout << currentNum << " " << std::endl;
//     if(cmpCount < 2 ) {
//       currentNum = num.value;
//       if(--numberWithOneComp < 0) {
//         std::cout << "Series for " << n << ", more then two numbers have only" 
//                 << "one complementary number" << std::endl;
//         return {};
//       }
//     }
//     else if(cmpCount == 2) {
//       Number& firstCmp = cmpMap[num.cmpVec.at(0)];
//       Number& secondCmp = cmpMap[num.cmpVec.at(1)];
//       bool firstUsed = false;
//       bool secondUsed = false;
      
//       if(num.left == nullptr) {
//         if(firstCmp.right == nullptr) {
//           num.left = &firstCmp;
//           firstCmp.right = &num;
//           firstUsed = true;
//         }
//         else if(secondCmp.right == nullptr) {
//           num.left = &secondCmp;
//           secondCmp.right = &num;
//           secondUsed = true;
//         }
//         else {
//           std::cout << "Assert - M0" << std::endl;
//         }
//       }
      
//       if(num.right == nullptr) {
//         if(firstCmp.left == nullptr && !firstUsed ) {
//           num.right = &firstCmp;
//           firstCmp.left = &num;
//         }
//         else if(secondCmp.left == nullptr && !secondUsed) {
//           num.right = &secondCmp;
//           secondCmp.left = &num;
//         }
//         else {
//           std::cout << "Assert - M1" << std::endl;
//         }
//       }
    
//       //std::cout << num.left->value << " << " << num.value << " >> " << num.right->value << std::endl;
//     }
//   }
   
// //   std::cout << std::endl;
// //   std::cout << "==========================" << std::endl;
// //   std::cout << std::endl;
  
//   // Show complementary
// //   for(auto elem : cmpMap) {
// //     std::cout << "[" <<elem.first << "]: ";
// //     for(auto i : elem.second.cmpVec) {
// //       std::cout << i << ", ";
// //     }
// //     std::cout << std::endl;
// //   }
  
// //   std::cout << std::endl;
// //   std::cout << "==========================" << std::endl;
// //   std::cout << std::endl;
  
//   std::vector<int> resultSeries;
//   resultSeries.reserve(n);
  
//   // Test
//   resultSeries.push_back(currentNum);
//   cmpMap.at(currentNum).idx = 0;
  
//   std::unordered_set<int> alredyUsed = {currentNum};
  
//   int lastNum = 0;
//   std::vector<int> multiplePosibilites = {};
  
//   for(int idx = 1; idx < n; ++idx) {
//     int tmpNum = -1;
//     bool nextValueFound = false;
   
//     for(int num : cmpMap.at(currentNum).cmpVec) {
      
//      // std::cout << num <<", ";
//       if(num != lastNum && alredyUsed.count(num) == 0 && cmpMap.at(currentNum).cmpAlredyUsed.count(num) == 0) {
//         if (cmpMap[num].left == nullptr || cmpMap[num].right == nullptr || 
//             cmpMap[num].left->value == currentNum || cmpMap[num].right->value == currentNum) { 
//             if(tmpNum == -1) {
//               tmpNum = num;
//             }
//             else {
//               bool elemFind = false;
//               for (auto i : multiplePosibilites) {
//                 if(currentNum == i) {
//                   elemFind =true;
//                   break;
//                 }
//               }
              
//               if(!elemFind) {
//                 multiplePosibilites.push_back(currentNum);
//               }
//             }
//         }
//       }
//     }
//      std::cout << " M2 " << std::endl;
//     if(tmpNum != -1) {
//         lastNum = currentNum;
//         cmpMap.at(currentNum).cmpAlredyUsed.insert(tmpNum);
//         currentNum = tmpNum;
//         // Pass index of new element in vector
//         cmpMap.at(currentNum).idx = resultSeries.size();
//         resultSeries.push_back(currentNum);
        
//         alredyUsed.insert(currentNum);  
//       }
//       else {
//         // For test print result
// //         std::cout << "Faild Result (" << numberResult++ << "): ";
// //         for (auto num : resultSeries) {
// //           std::cout << num << ", ";
// //         }
// //         std::cout << std::endl;
//         // Delete last 
        
//         // Find index of the last multipossible element
//         if(multiplePosibilites.size() > 0) {
//           int lastMulti = multiplePosibilites.back();
//           int lastIdx = 0;
//           for(auto i : resultSeries) {
//             if(lastMulti == i) {
//               break;
//             }
//             lastIdx++;
//           }
          
//           idx--;
//           for (; idx > lastIdx; idx--) {
//             int elem = resultSeries.back();
//             cmpMap.at(elem).idx = -1;
//             cmpMap.at(elem).cmpAlredyUsed.clear();
//             alredyUsed.erase(elem);
//             resultSeries.pop_back();
            
//           }
//           currentNum = lastMulti;
//           lastNum = resultSeries.at(cmpMap[lastMulti].idx - 1);
          
// //           std::cout << "Test: " << currentNum << " << " << lastNum << std::endl; 
//           multiplePosibilites.pop_back();
//         }
//         else {
//           // No possible result - in teorii
//         }
//       }
//   }
//   return resultSeries;